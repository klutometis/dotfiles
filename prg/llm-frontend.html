<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Frontend Components - Interactive Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
            color: #fff;
        }
        
        #graph {
            width: 100vw;
            height: 100vh;
        }
        
        .node {
            cursor: pointer;
        }
        
        .node circle {
            stroke: #fff;
            stroke-width: 2px;
            transition: all 0.3s ease;
        }
        
        .node:hover circle {
            stroke-width: 4px;
        }
        
        .node text {
            font-size: 14px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            fill: #fff;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
        }
        
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 2px;
        }
        
        .link-feature {
            stroke-dasharray: 5, 5;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            max-width: 300px;
        }
        
        #info h2 {
            margin: 0 0 10px 0;
            font-size: 18px;
        }
        
        #info p {
            margin: 5px 0;
            font-size: 14px;
            line-height: 1.4;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
        }
        
        button {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 2px;
        }
        
        button:hover {
            background: #357abd;
        }
    </style>
</head>
<body>
    <svg id="graph"></svg>
    
    <div id="info">
        <h2>LLM Frontend Architecture</h2>
        <p>Click anywhere on the graph to add components!</p>
        <p>Drag nodes to rearrange the visualization.</p>
    </div>
    
    <div id="controls">
        <button onclick="resetGraph()">Reset</button>
        <button onclick="showAllFeatures()">Show All</button>
    </div>
    
    <script>
        // Configuration
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Node types and colors
        const nodeTypes = {
            user: { color: '#ff6b6b', radius: 40 },
            core: { color: '#4ecdc4', radius: 35 },
            feature: { color: '#45b7d1', radius: 30 },
            enhancement: { color: '#96ceb4', radius: 25 }
        };
        
        // Initial nodes and links
        let nodes = [
            { id: 'user', name: 'User', type: 'user', x: width / 2, y: height / 2, fixed: true },
            { id: 'frontend', name: 'Frontend UI', type: 'core', x: width / 2 + 150, y: height / 2 },
            { id: 'model-api', name: 'Model API', type: 'core', x: width / 2 + 350, y: height / 2 },
            { id: 'system-prompt', name: 'System Prompt', type: 'core', x: width / 2 + 350, y: height / 2 - 100 }
        ];
        
        let links = [
            { source: 'user', target: 'frontend', type: 'data' },
            { source: 'frontend', target: 'model-api', type: 'data' },
            { source: 'system-prompt', target: 'model-api', type: 'data' }
        ];
        
        // Feature nodes to be added
        const featureNodes = [
            { id: 'memory', name: 'Memory Store', type: 'feature', connects: ['frontend', 'model-api'] },
            { id: 'search', name: 'Web Search', type: 'feature', connects: ['model-api'] },
            { id: 'files', name: 'File Handler', type: 'feature', connects: ['frontend', 'model-api'] },
            { id: 'mcp', name: 'MCP Tools', type: 'feature', connects: ['model-api'] },
            { id: 'safety', name: 'Safety Filter', type: 'enhancement', connects: ['model-api', 'frontend'] },
            { id: 'auth', name: 'Auth System', type: 'enhancement', connects: ['frontend'] },
            { id: 'context', name: 'Context Manager', type: 'enhancement', connects: ['frontend', 'model-api'] },
            { id: 'cache', name: 'Response Cache', type: 'enhancement', connects: ['model-api'] }
        ];
        
        let currentFeatureIndex = 0;
        
        // Create SVG and groups
        const svg = d3.select('#graph')
            .attr('width', width)
            .attr('height', height);
            
        // Add arrow marker definitions
        svg.append('defs').selectAll('marker')
            .data(['arrow'])
            .enter().append('marker')
            .attr('id', d => d)
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 25)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#999');
            
        const g = svg.append('g');
        
        // Create force simulation
        const simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links).id(d => d.id).distance(120))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(d => nodeTypes[d.type].radius + 10));
            
        // Create link and node groups
        let link = g.append('g').selectAll('.link');
        let node = g.append('g').selectAll('.node');
        
        // Update function
        function update() {
            // Update links
            link = link.data(links, d => `${d.source.id || d.source}-${d.target.id || d.target}`);
            link.exit().remove();
            
            const linkEnter = link.enter()
                .append('line')
                .attr('class', d => `link ${d.type === 'feature' ? 'link-feature' : ''}`)
                .attr('marker-end', 'url(#arrow)');
                
            link = linkEnter.merge(link);
            
            // Update nodes
            node = node.data(nodes, d => d.id);
            node.exit().remove();
            
            const nodeEnter = node.enter()
                .append('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
                    
            nodeEnter.append('circle')
                .attr('r', d => nodeTypes[d.type].radius)
                .attr('fill', d => nodeTypes[d.type].color);
                
            nodeEnter.append('text')
                .text(d => d.name);
                
            node = nodeEnter.merge(node);
            
            // Update simulation
            simulation.nodes(nodes);
            simulation.force('link').links(links);
            simulation.alpha(0.3).restart();
        }
        
        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            if (d.id !== 'user') {
                d.fx = null;
                d.fy = null;
            }
        }
        
        // Tick function
        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);
                
            node.attr('transform', d => `translate(${d.x},${d.y})`);
        });
        
        // Click to add nodes
        svg.on('click', function(event) {
            // Don't add nodes if clicking on existing elements
            if (event.target.tagName !== 'svg') return;
            
            if (currentFeatureIndex < featureNodes.length) {
                const feature = featureNodes[currentFeatureIndex];
                const newNode = {
                    ...feature,
                    x: event.x,
                    y: event.y
                };
                
                nodes.push(newNode);
                
                // Add links for this feature
                feature.connects.forEach(targetId => {
                    links.push({
                        source: feature.id,
                        target: targetId,
                        type: 'feature'
                    });
                });
                
                currentFeatureIndex++;
                update();
            }
        });
        
        // Reset function
        function resetGraph() {
            nodes = nodes.slice(0, 4); // Keep only initial nodes
            links = links.slice(0, 3); // Keep only initial links
            currentFeatureIndex = 0;
            update();
        }
        
        // Show all features
        function showAllFeatures() {
            while (currentFeatureIndex < featureNodes.length) {
                const feature = featureNodes[currentFeatureIndex];
                const angle = (currentFeatureIndex / featureNodes.length) * 2 * Math.PI;
                const radius = 200;
                
                const newNode = {
                    ...feature,
                    x: width / 2 + radius * Math.cos(angle),
                    y: height / 2 + radius * Math.sin(angle)
                };
                
                nodes.push(newNode);
                
                feature.connects.forEach(targetId => {
                    links.push({
                        source: feature.id,
                        target: targetId,
                        type: 'feature'
                    });
                });
                
                currentFeatureIndex++;
            }
            update();
        }
        
        // Zoom functionality
        const zoom = d3.zoom()
            .scaleExtent([0.5, 3])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });
            
        svg.call(zoom);
        
        // Initial update
        update();
    </script>
</body>
</html>
